{"version":3,"sources":["webpack://EUIComponent/webpack/bootstrap","webpack://EUIComponent/./src/utils/helpers.js","webpack://EUIComponent/./src/utils/exports.js","webpack://EUIComponent/./src/Stateless.js","webpack://EUIComponent/./src/utils/propTypes.js","webpack://EUIComponent/./src/Component.js","webpack://EUIComponent/./src/renderers/Template.js","webpack://EUIComponent/./src/utils/definition.js","webpack://EUIComponent/./src/mixins/Store.js","webpack://EUIComponent/./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","addClassNames","customElement","shadowRoot","querySelectorAll","forEach","el","classList","add","localName","prepareTemplate","template","document","querySelector","ShadyCSS","whenComponentsAreDefined","root","undefinedComponents","promises","Array","slice","map","component","customElements","whenDefined","Promise","all","e","resolve","requestAnimationFrame","sym","description","String","undefined","noise","split","replace","Math","random","toString","microtaskDebounce","fn","isQueued","createElement","MutationObserver","observe","childList","textContent","warn","message","console","bubble","context","detail","config","event","CustomEvent","bubbles","composed","dispatchEvent","dashToCamel","input","match","substr","toUpperCase","camelToDash","toLowerCase","compatUpdated","shadyPrepared","obj","window","innerHTML","styleElement","_shadyPrepared","nativeShadow","eventHandlers","entries","addEventListener","removeEventListener","prop","options","target","descriptor","writable","initializer","constructor","_propDefs","assign","registerMixin","superMixins","mixins","from","includes","push","hasMixin","Base","_mixins","indexOf","mixinName","helpers","super","this","_lifecycleDebounced","_executeLifecycle","connectedCallback","intercepts","disconnectedCallback","compatElementUpdated","executeComponentRender","safeParse","JSON","parse","typeMapping","type","coerce","serialize","deserialize","Boolean","Number","isNaN","stringify","isArray","components","is","componentClass","define","customName","_prevProps","_connected","_justConnected","_findProps","_setAttributes","didDisconnect","componentWillDisconnect","keys","reduce","memo","_observedAttributes","filter","attribute","propDef","defaultValue","default","attributes","required","valueSymbol","existingValue","set","v","_syncPropertyToAttribute","componentDidConnect","componentDidReceiveProps","prev","shouldComponentRender","componentWillRender","componentDidUpgrade","componentDidRender","didConnect","didChangeProps","changedProps","shouldRender","flag","some","oldShould","willRender","executeRender","didUpgrade","didRender","propMap","Map","startsWith","has","updateLocale","locale","home","localePath","_fetch","_getWindow","localeFile","localeStrings","json","i18n","triggerComponentUpdate","attributeChangedCallback","oldValue","newValue","propName","_syncAttributeToProperty","prevWasUndefined","_setDiff","props","_shouldRenderLocale","previous","current","changes","_syncingAttributeToProperty","_syncingPropertyToAttribute","attributeName","removeAttribute","setAttribute","Shady","attachShadow","_template","styleText","div","clone","content","cloneNode","style","appendChild","createTextNode","prepend","getTemplateElement","_initialized","init","then","id","selector","currentScript","ownerDocument","_currentScript","trigger","eventName","find","many","getElementById","APPEND","PREPEND","definition","templatePosition","_event","configKeysPath","$components","callback","data","setHome","targetStyle","optionStyle","setStyles","targetTemplate","optionTemplate","pos","setTemplates","StoreMixin","_stateChanged","getState","provider","store","dispatch","action","payload","storeDisconnect","properties","disconnect","storeConnect","connect","addActions","actionName","func","listen","removeActions","unlisten","state","Stateless","StatelessComponentMixin","HTMLElement","Component","StatefulComponentMixin","TemplateComponent","Template"],"mappings":"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","file":"Main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* global requestAnimationFrame, MutationObserver:0, ShadyCSS */\n/* eslint arrow-body-style:0 */\n\n// export const registerMixin = (superMixins, name) => {\n//   const mixins = superMixins ? Array.from(superMixins) : [];\n//   if (!mixins.includes(name)) {\n//       mixins.push(name);\n//   }\n//   return mixins;\n// };\n//\n// export const hasMixin = (Base, name) => {\n//   return Base._mixins !== undefined && Base._mixins.indexOf(name) > -1;\n// };\n\nconst whenComponentsAreDefined = (root) => {\n  try {\n    const undefinedComponents = root.querySelectorAll(':not(:defined)');\n    const promises = Array.prototype.slice.call(undefinedComponents)\n        .map(component => customElements.whenDefined(component.localName));\n    return Promise.all(promises);\n  } catch (e) {\n    // this fails in firefox because the selector is not valid,\n    // so just wait a frame and all components are more likely\n    // to be updated at that point.\n    return new Promise(((resolve) => {\n        requestAnimationFrame(resolve);\n    }));\n  }\n};\n\n/**\n * @description Polyfill for Symbol - returns a random string if not supported\n */\nconst sym = (description) => {\n  if (typeof Symbol === 'function') {\n    return Symbol(description ? String(description) : undefined);\n  }\n  // Symbol not supported, make a random string\n  const noise = 'xxxxxx'\n  .split('')\n  /* eslint no-bitwise:0 */\n  .replace(/./g, () => (Math.random() * 16 | 0).toString(16));\n  return `${description ? String(description) : ''}-${noise}`;\n};\n\n/**\n * @description Debounce a 0-arg function into the microtask queue using a MutationObserver.\n * This ensures that the update will be processed on the tail-end of this task,\n * before the next tick / browser repaint.\n * More info on this approach:\n * https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n *\n * @param {Function} fn\n * @return {Function}\n */\nconst microtaskDebounce = (fn) => {\n  let isQueued = false;\n  const el = document.createElement('i');\n  new MutationObserver(() => {\n    fn();\n    isQueued = false;\n  }).observe(el, { childList: true });\n  let i = 0;\n  return () => {\n    if (!isQueued) {\n      isQueued = true;\n      el.textContent = `${i}`;\n      i += 1;\n    }\n  };\n};\n\n/**\n * @description Warn the developer about improper library usage.\n * @todo: Make only active in dev mode (no-op in production)\n */\nconst warn = (message) => { console.warn(message); };\n\n// COMPAT\n/**\n * Manually add the correct scoped classnames, if ShadyCSS doesn't\n * seem to be doing its job.\n */\nconst addClassNames = (customElement) => {\n  customElement.shadowRoot.querySelectorAll('*').forEach((el) => {\n    el.classList.add(customElement.localName);\n    el.classList.add('style-scope');\n  });\n};\n\n/**\n * ShadyCSS prepareTemplate, but check it's not doubling up\n */\nconst prepareTemplate = (template, name) => {\n  if (document.querySelector(`head > style[scope=${name}]`) == null) {\n    ShadyCSS.prepareTemplate(template, name);\n  }\n};\n\n// DOM EVENTS\nconst bubble = (context, name, detail = {}, config = {}) => {\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    composed: true,\n    ...config,\n    detail,\n  });\n  context.dispatchEvent(event);\n  return event;\n};\n\n// PROPS\n/**\n * Transform dash-case (HTML) into camelCase (JS)\n * @param {string} input\n * @returns {string}\n */\nconst dashToCamel = (input) => {\n  /* eslint no-useless-escape:0 */\n  return input.replace(/\\-./g, match => match.substr(1).toUpperCase());\n};\n\n/**\n* Transform camelCase (JS) into dash-case (HTML)\n*\n* @param {string} input\n* @returns {string}\n*/\nconst camelToDash = (input) => {\n  return input.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\n};\n\nconst compatUpdated = (shadyPrepared, obj) => {\n  if (window.ShadyCSS) {\n    // Things which only need to happen on the first render\n    if (!shadyPrepared) {\n      const template = document.createElement('template');\n      template.innerHTML = obj.shadowRoot.innerHTML;\n      prepareTemplate(template, obj.localName);\n      ShadyCSS.styleElement(obj);\n      obj._shadyPrepared = true;\n    }\n    // Things which need to happen on prop update\n    // ShadyCSS.styleSubtree(this);\n    if (!ShadyCSS.nativeShadow) {\n      obj.shadowRoot.querySelectorAll('style').forEach((el) => {\n        el.textContent = '';\n      });\n      addClassNames(obj);\n    }\n  }\n};\n\nconst eventHandlers = (obj, add = true) => {\n  if (obj) {\n    if (add) {\n      Object.entries(obj).forEach(([key, value]) => {\n        this.addEventListener(key, value);\n      });\n      return;\n    }\n    Object.entries(obj).forEach(([key, value]) => {\n      this.removeEventListener(key, value);\n    });\n  }\n};\n\nexport default {\n  whenComponentsAreDefined,\n  sym,\n  microtaskDebounce,\n  warn,\n  addClassNames,\n  prepareTemplate,\n  bubble,\n  dashToCamel,\n  camelToDash,\n  compatUpdated,\n  eventHandlers,\n};\n","/**\n * A decorator used to decorate props in a component.\n * use like...\n *\n * @prop({\n *   attribute: [true|false],\n *   type: ['string'|'number'|'boolean'|'array'|'object'],\n *   default: value, required: [true|false]})\n * propA;\n *\n * @param {Object} options - define the prop.\n */\nexport function prop(options = {}) {\n  /* eslint func-names: 0 */\n  return function (target, name, descriptor) {\n    // Some stuff which is needed to stop babel decorators-legacy from\n    // overwriting the property descriptor with a `value` type.\n    // See: https://stackoverflow.com/questions/39267780/how-to-disable-defining-class-properties-in-babel-transform-decorators-legacy\n    delete descriptor.writable;\n    descriptor.get = function () {};\n    delete descriptor.initializer;\n    target.constructor._propDefs = Object.assign(\n      {},\n      target.constructor._propDefs,\n      { [name]: options },\n    );\n  };\n}\n\nexport const registerMixin = (superMixins, name) => {\n  const mixins = superMixins ? Array.from(superMixins) : [];\n  if (!mixins.includes(name)) {\n      mixins.push(name);\n  }\n  return mixins;\n};\n\n// eslint-disable-next-line max-len\nexport const hasMixin = (Base, name) => Base._mixins !== undefined && Base._mixins.indexOf(name) > -1;\n","import helpers from './utils/helpers';\nimport { registerMixin, hasMixin } from './utils/exports';\n\nexport default (Base) => {\n  const mixinName = 'StatelessComponentMixin';\n  const {\n    eventHandlers,\n    compatUpdated,\n    bubble,\n    microtaskDebounce,\n   } = helpers;\n\n   if (hasMixin(Base, mixinName)) {\n    console.warn(`Tried to add existing mixin ${mixinName}`);\n    return Base;\n  }\n  return class Stateless extends Base {\n    static get _mixins() {\n      return registerMixin(super._mixins, mixinName);\n    }\n\n    constructor() {\n      super();\n      this._shadyPrepared = false;\n      this._lifecycleDebounced = microtaskDebounce(this._executeLifecycle.bind(this));\n    }\n\n    connectedCallback() {\n      this._executeLifecycle();\n      eventHandlers(this.intercepts);\n    }\n\n    disconnectedCallback() { eventHandlers(this.intercepts, false); }\n\n    compatElementUpdated() { compatUpdated(this._shadyPrepared, this); }\n\n    bubble(name, detail = {}, config = {}) { return bubble(this, name, detail, config); }\n\n    _executeLifecycle() { this.executeComponentRender(); }\n\n    executeComponentRender() { }\n  };\n};\n","export const safeParse = (value) => {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    if (e.name === 'SyntaxError') {\n      console.warn(`Invalid JSON: '${value}'`);\n    }\n    return null;\n  }\n};\n\nexport const typeMapping = (type) => {\n  switch (type) {\n    case String:\n    case 'string': // TODO: remove this line before version 1.0.\n      return {\n        coerce: value => (value == null ? null : String(value)),\n        serialize: value => (value == null ? null : String(value)),\n        deserialize: value => value,\n      };\n\n    case Boolean:\n    case 'boolean': // TODO: remove this line before version 1.0.\n      return {\n        coerce: value => Boolean(value),\n        serialize: value => (value ? '' : null),\n        deserialize: value => value != null,\n      };\n\n    case Number:\n    case 'number': // TODO: remove this line before version 1.0.\n      return {\n        /* eslint no-restricted-globals:0 */\n        coerce: value => ((value == null || isNaN(value))\n        ? null\n        : Number(value)),\n        serialize: value => (value == null ? null : String(value)),\n        deserialize: value => (value == null ? null : Number(value)),\n      };\n\n    case Object:\n    case 'object': // TODO: remove this line before version 1.0.\n      return {\n        coerce: value => ((value == null || typeof value !== 'object')\n        ? null\n        : value),\n        serialize: value => (value == null ? null : JSON.stringify(value)),\n        deserialize: value => (value == null ? null : safeParse(value)),\n      };\n\n    case Array:\n    case 'array': // TODO: remove this line before version 1.0.\n      return {\n        coerce: value => (Array.isArray(value) ? value : null),\n        serialize: value => (value == null ? null : JSON.stringify(value)),\n        deserialize: value => (value == null ? null : safeParse(value)),\n      };\n\n    default:\n      return {\n        coerce: value => value,\n        serialize: value => value,\n        deserialize: value => value,\n      };\n  }\n};\n","import { registerMixin, hasMixin } from './utils/exports';\nimport helpers from './utils/helpers';\nimport { typeMapping } from './utils/propTypes';\n\nexport default (Base) => {\n  // Define the mixin name, this is required to determine if the mixin has\n  // Already been applied\n  const mixinName = 'StatefulComponent';\n  // Determine if there is an attempt to re initialize the mixin\n  if (hasMixin(Base, mixinName)) {\n    console.warn(`Tried to add existing mixin ${mixinName}`);\n    return Base;\n  }\n  return class StatefulComponent extends Base {\n    static get _mixins() {\n      return registerMixin(super._mixins, mixinName);\n    }\n\n    /**\n     * Define the components as Custom Elements.\n     *\n     * @function registerComponents\n     * @param { Array } components - array of components\n     */\n    static registerComponents(components) {\n      if (!components) {\n        console.warn('No component provided to register');\n        return;\n      }\n      if (!Array.isArray(components)) {\n        console.warn('incorrect type provided');\n        return;\n      }\n      components.forEach((component) => {\n        const { is } = component;\n        let { componentClass } = component;\n        if (typeof component === 'object' && (!is || !componentClass)) {\n          console.warn('Object:component not defined properly');\n          return;\n        }\n\n        if (!componentClass) {\n          // if componentclass is not specified explictly, its same as component.\n          componentClass = component;\n        }\n        if (customElements.get(is)) {\n          console.warn(`customElement ${is} has already been defined`);\n        } else {\n          customElements.define(is, componentClass);\n        }\n      });\n    }\n\n    /**\n     * Define the component as a Custom Element. The optional customName MUST be a valid\n     * custom element and contain at least one dash (-).\n     *\n     * @function register\n     * @param { String } customName - name of the component\n     */\n    static register(customName) {\n      if (customName) {\n        this.is = customName;\n      }\n      if (customElements.get(this.is)) {\n        console.warn(`customElement ${this.is} has already been defined`);\n      } else {\n        customElements.define(this.is, this);\n      }\n    }\n\n    /**\n     * @protected\n     * @function constructor\n     * @description Parse the custom element attributes as props\n     */\n    constructor() {\n      super();\n      // COMPAT\n      this._shadyPrepared = false;\n\n      // PROPS\n      this._prevProps = undefined;\n      this._connected = false;\n      this._justConnected = false;\n      // Debounce prop updates leading to lifecycle callbacks, so that\n      // setting multiple props in sequence (e.g. via a declarative\n      // renderer calling setAttribute many times) just triggers one big\n      // update, not several partial ones.\n      this._lifecycleDebounced = helpers.microtaskDebounce(this._executeLifecycle.bind(this));\n      // Find any props initialize for the component\n      if (this.constructor._propDefs) {\n        this._findProps();\n      }\n    }\n\n    /**\n     * @protected\n     * @function connectedCallback\n     * @description The Default connected callback\n     */\n    connectedCallback() {\n      // DOM EVENTS\n      helpers.eventHandlers(this.intercepts);\n      this._setAttributes();\n      this._connected = true;\n      this._justConnected = true;\n      this._lifecycleDebounced();\n    }\n\n    /**\n     * @protected\n     * @function disconnectedCallback\n     * @description The Default disconnected callback\n     */\n    disconnectedCallback() {\n      // DOM EVENTS\n      helpers.eventHandlers(this.intercepts, false);\n      this.didDisconnect();\n\n      // TODO: deprecate componentWillDisconnect\n      this.componentWillDisconnect();\n\n      this._connected = false;\n    }\n\n    // COMPAT\n    /**\n     * @description Call this from your renderer once you've rendered to the DOM\n     */\n    compatElementUpdated() {\n      helpers.compatUpdated(this._shadyPrepared, this);\n    }\n\n    // DOM EVENTS\n    bubble(name, detail = {}, config = {}) { return helpers.bubble(this, name, detail, config); }\n\n    /**\n     * @description Get object with current values of all props in this INSTANCE.\n     */\n    get props() {\n      if (this.constructor._propDefs) {\n        // Loop through the component's CONSTRUCTOR props definition\n        return Object.keys(this.constructor._propDefs).reduce((memo, key) => {\n          memo[key] = this[key];\n          return memo;\n        }, {});\n      }\n      return {};\n    }\n\n    /**\n     * @description Let the browser know which attributes to observe.\n     * Part of the Custom Elements v1 spec, the browser will observe all\n     * the attributes listed here, triggering attributeChangedCallback any\n     * time they are set\n     * @return {string[]}\n     */\n    static get observedAttributes() {\n      if (this._propDefs !== undefined) {\n        this._observedAttributes = Object.entries(this._propDefs)\n        // eslint-disable-next-line no-unused-vars\n        .filter(([key, value]) => value.attribute === true)\n        // eslint-disable-next-line no-unused-vars\n        .map(([key, value]) => helpers.camelToDash(key));\n      }\n      return this._observedAttributes;\n    }\n\n    /**\n     * Loop over each prop defined by the user and set the values for props.\n     *\n     * @function _setAttributes\n     * @private\n     */\n    _setAttributes() {\n      if (this.constructor._propDefs) {\n        Object.entries(this.constructor._propDefs).forEach(([key, propDef]) => {\n          const defaultValue = propDef.default;\n\n          // Attributes can't be set in the constructor, and must be\n          // deferred to the connectedCallback, as per the spec.\n          if (this[key] === undefined\n            && this.attributes[helpers.camelToDash(key)] === undefined\n            && !propDef.required) {\n              switch (propDef.type) {\n                case Object:\n                case 'object': // TODO: remove this line before version 1.0.\n                  this[key] = defaultValue !== undefined ? { ...defaultValue } : null;\n                  break;\n\n                case Array:\n                case 'array': // TODO: remove this line before version 1.0.\n                  this[key] = defaultValue !== undefined ? [...defaultValue] : null;\n                  break;\n\n                default:\n                  this[key] = defaultValue !== undefined ? defaultValue : null;\n              }\n            }\n          });\n        }\n      }\n\n      /**\n       * @private\n       * @description Find an props for the component\n       */\n      _findProps() {\n        // Loop over each prop defined by the user\n        Object.entries(this.constructor._propDefs).forEach(([key, propDef]) => {\n          // Use a Symbol to avoid cluttering object namespace\n          const valueSymbol = helpers.sym(key);\n          const { coerce, serialize } = typeMapping(propDef.type);\n          const defaultValue = propDef.default;\n          const existingValue = this[key];\n          // Warn against bad API usage\n          if (propDef.required && propDef.default !== undefined) {\n            helpers.warn(`[${this.constructor.is}] Required prop \"${key}\" should not also have a default set`);\n          }\n          // Apply custom getters/setters to the property\n          // TODO: Could move this to the prototype for efficiency\n          Object.defineProperty(this, key, {\n            // configurable: false,\n          enumerable: true,\n          get() {\n            return this[valueSymbol];\n          },\n          set(v) {\n            // Make sure the received value is of the expected type\n            let value = coerce(v);\n            if (value == null) {\n              // Was it required?  If so, this shouldn't be happening\n              if (propDef.required) {\n                helpers.warn(`[${this.constructor.is}] Required prop \"${key}\" should not be set to null/undefined`);\n              }\n              // Use the default value if one was provided\n              if (defaultValue !== undefined) {\n                value = defaultValue;\n              }\n            }\n            this[valueSymbol] = value;\n            if (propDef.attribute === true) {\n              this._syncPropertyToAttribute(key, value, serialize);\n            }\n            \n            this._lifecycleDebounced();\n          },\n        });\n        if (existingValue != null) { this[key] = existingValue; }\n      });\n    }\n\n    /**\n     * LIFECYCLE HOOKS (DEPRECATED)\n     */\n\n    /**\n     * @description Lifecyce hook\n     * The component has been connected to the DOM (even with the polyfill,\n     * which happens asynchronously).\n     * Unlike in the constructor, all props are accessible, so this is a\n     * good place to set initial internal state values (or reset them, if\n     * this component could be connected multiple times).\n     * Also good time to create any subscribers (remember to destroy them\n     * later), or bubble any events.\n     *\n     * @deprecated\n     */\n    componentDidConnect() { }\n\n    /**\n     * @description Lifecycle hook\n     * Option to set internal state based on newly received external props.\n     * Also a good place to do things like send off ajax requests in\n     * response to changing props.\n     * Make sure to compare prev/current values to be sure it's actually changed.\n     * Legacy compatibility\n     * @param {Object} prev\n     * @deprecated\n     */\n    // eslint-disable-next-line no-unused-vars\n    componentDidReceiveProps(prev) { }\n\n    /**\n     * @description Lifecycle hook\n     * Determine whether the props have changed enough to need a re-render\n     * Defaults to using a shallow === check, so won't pick up deep changes\n     * in objects (for example).  Use the immutable pattern to avoid this.\n     * this.someProp = { ...this.someProp, foo: 'new' }\n     * You could also override this to perform a different checking logic\n     * in a component, if you need.\n     * @param {Object} prev Previous values of props\n     * @return {boolean} True to trigger a re-render\n     * Legacy support\n     * @deprecated\n     */\n    // eslint-disable-next-line no-unused-vars\n    shouldComponentRender(prev) {\n      return null;\n    }\n\n    /**\n     * @description Lifecycle hook\n     * Option to do any preparation needed for a render.\n     * Do not set internal state here.\n     * @param {Object} prev\n     * @deprecated\n     */\n    // eslint-disable-next-line no-unused-vars\n    componentWillRender(prev) { }\n\n    /**\n     * @description Lifecycle hook\n     * Renderers should hook into this.\n     * @deprecated\n     */\n    executeComponentRender() { }\n\n    /**\n     * @description Lifecycle hook\n     * Implement this hook in your component if you are interested\n     * to know when the component is upgraded.\n     * Renderers should call this only once when the shadowRoot is\n     * attached and the template is added.\n     *\n     * Executes only once in the component lifecycle.\n     * Initial render has taken place and changes flushed to the DOM.\n     * All props are accessible and the shadowRoot is available.\n     * This hook gives the ability to check the presence of slotted children.\n     *\n     * If the component listens for slotchange events on a slot, then this\n     * is the place to get their initial state. In Safari browser the\n     * component is mutated before the shadowRoot is added which means\n     * the slotchange won't fire on first render.\n     * @deprecated\n     */\n    componentDidUpgrade() { }\n\n    /**\n     * @description Lifecycle hook\n     * Rendering has taken place and changes flushed to the DOM, so an\n     * opportunity to carry out any imperative updates that may be needed.\n     * Frequently used to imperatively set props on slotted children.\n     * Do not set internal state here.\n     * Legacy compatibility\n     * @param {Object} prev\n     * @deprecated\n     */\n    // eslint-disable-next-line no-unused-vars\n    componentDidRender(prev) { }\n\n    /**\n     * @description Lifecycle hook\n     * Component is about to be disconnected from the DOM (but may be\n     * connected again later...).\n     * Good time to remove any subscribers.\n     * @deprecated\n     */\n    componentWillDisconnect() { }\n\n    /**\n     * LIFECYCLE HOOKS\n     */\n\n    /**\n     * Lifecyce hook\n     * The component has been connected to the DOM (even with the polyfill,\n     * which happens asynchronously).\n     * Unlike in the constructor, all props are accessible, so this is a\n     * good place to set initial internal state values (or reset them, if\n     * this component could be connected multiple times).\n     * Also good time to create any subscribers (remember to destroy them\n     * later), or bubble any events.\n     *\n     * This replaces the deprecated componentDidConnect() lifecycle hook.\n     *\n     * Call order:\n     * connectedCallback() -> didConnect() -> didChangeProps()\n     *\n     * @function didConnect\n     */\n    didConnect() {}\n\n    /**\n     * Lifecycle hook\n     * Option to set internal state based on newly received external props.\n     * Also a good place to do things like send off ajax requests in\n     * response to changing props.\n     * Make sure to compare prev/current values to be sure it's actually changed.\n     *\n     * This replaces the deprecated componentDidReceiveProps(prev) lifecycle hook.\n     *\n     * @function didChangeProps\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     */\n    // eslint-disable-next-line no-unused-vars\n    didChangeProps(changedProps) {}\n\n    // TODO: this function should be re-written so the user doesn't need\n    // to call super.shouldRender(prev); componentShouldRender is doing more\n    // than just providing a hook.\n    /**\n     * Lifecycle hook\n     * Determine whether the props have changed enough to need a re-render\n     * Defaults to using a shallow === check, so won't pick up deep changes\n     * in objects (for example).  Use the immutable pattern to avoid this.\n     * this.someProp = { ...this.someProp, foo: 'new' }\n     * You could also override this to perform a different checking logic\n     * in a component, if you need.\n     *\n     * This replaces the deprecated shouldComponentRender(prev) lifecycle hook.\n     *\n     * @function shouldRender\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     * @return {boolean} True to trigger a re-render\n     */\n    shouldRender(changedProps, prev = {}) {\n      const flag = [...changedProps].some(([key, value]) => value !== this[key]);\n      const oldShould = this.shouldComponentRender(prev);\n      return oldShould === null ? flag : oldShould;\n    }\n\n    /**\n     * Lifecycle hook\n     * Option to do any preparation needed for a render.\n     * Do not set internal state here.\n     *\n     * This replaces the deprecated componentWillRender(prev) lifecycle hook.\n     *\n     * @function willRender\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     */\n    // eslint-disable-next-line no-unused-vars\n    willRender(changedProps) {}\n\n    /**\n     * Lifecycle hook\n     * Renderers should hook into this.\n     *\n     * This replaces the deprecated executeComponentRender() lifecycle hook.\n     *\n     * @function executeRender\n     */\n    executeRender() {}\n\n    /**\n     * Lifecycle hook\n     * Implement this hook in your component if you are interested\n     * to know when the component is upgraded.\n     * Renderers should call this only once when the shadowRoot is\n     * attached and the template is added.\n     *\n     * Executes only once in the component lifecycle.\n     * Initial render has taken place and changes flushed to the DOM.\n     * All props are accessible and the shadowRoot is available.\n     * This hook gives the ability to check the presence of slotted children.\n     *\n     * If the component listens for slotchange events on a slot, then this\n     * is the place to get their initial state. In Safari browser the\n     * component is mutated before the shadowRoot is added which means\n     * the slotchange won't fire on first render.\n     *\n     * This replaces the deprecated componentDidUpgrade() lifecycle hook.\n     *\n     * @function didUpgrade\n     */\n    didUpgrade() {}\n\n    /**\n     * Lifecycle hook\n     * Rendering has taken place and changes flushed to the DOM, so an\n     * opportunity to carry out any imperative updates that may be needed.\n     * Frequently used to imperatively set props on slotted children.\n     * Do not set internal state here.\n     *\n     * This replaces the deprecated componentDidRender() lifecycle hook.\n     *\n     * @function didRender\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     */\n    // eslint-disable-next-line no-unused-vars\n    didRender(changedProps) {}\n\n    /**\n     * Lifecycle hook\n     * Component is about to be disconnected from the DOM (but may be\n     * connected again later...).\n     * Good time to remove any subscribers.\n     *\n     * This replaces the deprecated componentWillDisconnect() lifecycle hook.\n     *\n     * @function didDisconnect\n     */\n    didDisconnect() {}\n\n    /**\n     * Get the property definitions as defined for the component.\n     * @returns {Map}\n     */\n    get propDefinitions() {\n      const propMap = new Map();\n      Object.keys(this.constructor._propDefs)\n      .filter(key => !key.startsWith('_'))\n      .forEach((key) => {\n        propMap.set(key, this.constructor._propDefs[key]);\n      });\n      return propMap;\n    }\n\n    /**\n     * This function is used to check if the locale prop was changed. If so then the new locale\n     * must be fetched.\n     *\n     * @function _shouldRenderLocale\n     * @param {Map} changedProps - Keys are the names of changed properties;\n     * Values are the corresponding previous values.\n     * @private\n     */\n    async _shouldRenderLocale(changedProps) {\n      if (changedProps.has('locale')) {\n        await this.constructor.updateLocale(this.locale);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @description returns the global window property\n     * @param {String} prop\n     */\n    static _getWindow(prop) {\n      return window[prop];\n    }\n\n    /**\n     * @description Updates the components' locale\n     * @param {string} locale\n     */\n    static async updateLocale(locale) {\n      if (!locale) { return; }\n\n      const { home } = this;\n      if (!home) { return; }\n\n      let localePath = `locale/${locale}.json`;\n      if (home !== '/') {\n        localePath = `${home}/locale/${locale}.json`;\n      }\n\n      try {\n        const _fetch = this._getWindow('fetch');\n        const localeFile = await _fetch(localePath);\n        const localeStrings = await localeFile.json();\n        this.i18n = localeStrings;\n      } catch (e) {\n        console.warn('Component: Error loading locale: %o, error: %o', localePath, e);\n      }\n    }\n\n    /**\n     * @description Manually trigger lifecycle callbacks.  Would be used in conjunction\n     * with a custom arePropsChangedCallack.\n     */\n    triggerComponentUpdate() { this._lifecycleDebounced(); }\n\n\n    /**\n     * @description Called (as part of HTML spec) when attribute changes\n     * @param {string} name\n     * @param {string} oldValue\n     * @param {string} newValue\n     */\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, oldValue, newValue);\n      }\n      const propName = helpers.dashToCamel(name);\n      const propDef = this.constructor._propDefs[propName];\n      const { deserialize } = typeMapping(propDef.type);\n      if (propDef && propDef.attribute === true) {\n        this._syncAttributeToProperty(propName, newValue, deserialize);\n      }\n    }\n\n    /**\n     * @description Invoke the props changed/rendering lifecycle\n     */\n    async _executeLifecycle() {\n      // Skip lifecycle callbacks if component isn't connected. Don't\n      // want to try manipulating a DOM tree that doesn't exist.\n      if (!this._connected) {\n        return;\n      }\n      \n      // Prev/next callbacks, passed on to lifecycle callbacks\n      const prevWasUndefined = this._prevProps === undefined;\n      const prev = prevWasUndefined ? {} : this._prevProps;\n      \n      const changedProps = this._setDiff(prev, this.props);\n      \n      // Initial render only\n      if (this._justConnected) {\n        // Check for any missing required props\n        if (this.constructor._propDefs) {\n          Object.entries(this.constructor._propDefs).forEach(([key, propDef]) => {\n            if (propDef.required && this[key] == null) {\n              helpers.warn(`[${this.constructor.is}] Required prop \"${key}\" was not set`);\n            }\n          });\n        }\n        this.didConnect();\n\n        // TODO: deprecate componentDidConnect\n        this.componentDidConnect();\n\n        this._justConnected = false;\n      }\n\n      this.didChangeProps(changedProps);\n\n      // TODO: deprecate componentDidReceiveProps\n      this.componentDidReceiveProps(prev);\n\n      // Set _prevProps ready for next update, after giving the user a\n      // chance to update internal state props in earlier lifecycle hooks\n      this._prevProps = this.props;\n\n      if (prevWasUndefined) {\n        await this.constructor.updateLocale(this.locale);\n      }\n\n      // Never let the user bypass the initial render.\n      if (prevWasUndefined || await this._shouldRenderLocale(changedProps) || this.shouldRender(changedProps, prev)) {\n        this.willRender(changedProps);\n\n        // TODO: deprecate componentDidReceiveProps\n        this.componentWillRender(prev);\n\n        this.executeRender();\n\n        // TODO: deprecate executeComponentRender\n        this.executeComponentRender();\n\n        this.didRender(changedProps);\n\n        // TODO: deprecate componentDidRender\n        this.componentDidRender(prev);\n      }\n    }\n\n    /**\n     * Perform a comparison between previous prop values and current prop values\n     * to determine differences. Each different prop (key:value) is put into a Map.\n     * This Map is set as the changeProps map and used as input to all lifecycle callbacks.\n     *\n     * @function _setDiff\n     * @param {Object} previous - previous prop values\n     * @param {Object} current - current prop values\n     * @private\n     */\n    _setDiff(previous, current) {\n      const changes = new Map();\n      const keys = Object.keys(previous);\n      keys.forEach((key) => {\n        if (previous[key] !== current[key]) {\n          changes.set(key, previous[key]);\n        }\n      });\n      return changes;\n    }\n\n    /**\n     * Sync the HTML attribute value to the JS object property\n     *\n     * @param {string} name\n     * @param {string} value\n     */\n    _syncAttributeToProperty(name, v, deserialize) {\n      if (name in (this.constructor._propDefs)) {\n        this._syncingAttributeToProperty = true;\n        // Deserialize based on prop type\n        const value = deserialize(v);\n        this[name] = value;\n        this._syncingAttributeToProperty = false;\n      }\n    }\n\n    /**\n     * Sync a property value to an HTML attribute\n     * @param {string} name\n     * @param {*} value\n     */\n    _syncPropertyToAttribute(name, v, serialize) {\n      if (!this._syncingAttributeToProperty) {\n        this._syncingPropertyToAttribute = true;\n        // Serialize to string | null\n        const value = serialize(v);\n        const attributeName = helpers.camelToDash(name);\n        if (value == null) {\n          this.removeAttribute(attributeName);\n        } else {\n          this.setAttribute(attributeName, value);\n        }\n        this._syncingPropertyToAttribute = false;\n      }\n    }\n  };\n};\n","/* global ShadyCSS */\nimport { registerMixin, hasMixin } from '../utils/exports';\nimport helpers from '../utils/helpers';\n\nconst Shady = window.ShadyCSS !== undefined;\nconst { whenComponentsAreDefined } = helpers;\n/**\n * @description Adds a simple renderer using static template tags.\n * @TODO Fix ShadyCSS support\n */\nexport default (Base) => {\n  function getTemplateElement(template, styleText) {\n    if (template === undefined) {\n      template = '';\n    }\n\n    if (typeof template === 'string') {\n      const div = document.createElement('div');\n      div.innerHTML = `<template id=\"the-template\">${template}</template>`;\n      template = div.querySelector('template#the-template');\n    }\n    const clone = template.content.cloneNode(template, true);\n\n    if (typeof styleText === 'string') {\n      const style = document.createElement('style');\n      style.appendChild(document.createTextNode(styleText));\n      clone.prepend(style);\n    }\n    return clone;\n  }\n\n  const mixinName = 'Template';\n  if (hasMixin(Base, mixinName)) {\n    console.warn(`Tried to add existing mixin ${mixinName}`);\n    return Base;\n  }\n\n  return class Template extends Base {\n    static get _mixins() {\n      return registerMixin(super._mixins, mixinName);\n    }\n\n    constructor() {\n      super();\n        this.attachShadow({ mode: 'open' });\n      this._template = getTemplateElement(\n        this.constructor.template,\n        this.constructor.style,\n      );\n      this.root.appendChild(this._template);\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n\n      if (!this._initialized) {\n        if (Shady) {\n          ShadyCSS.styleElement(this);\n        }\n        this._initialized = true;\n        if (this.init) {\n          // all the nested custom elements may not have been\n          // upgraded so we need to wait until they are.\n          // https://developers.google.com/web/fundamentals/architecture/\n          // building-components/customelements\n          // see the 'Element upgrades' section.\n          whenComponentsAreDefined(this.root).then(() => {\n            this.init();\n            this.didUpgrade();\n\n            // TODO: deprecate componentDidUpgrade\n            this.componentDidUpgrade();\n          });\n          return;\n        }\n        whenComponentsAreDefined(this.root).then(() => {\n          this.didUpgrade();\n          // TODO: deprecate componentDidUpgrade\n          this.componentDidUpgrade();\n        });\n      }\n    }\n\n    get root() {\n      return this.shadowRoot;\n    }\n\n    static getTemplate(id) {\n      const selector = (id) ? `#${id}` : 'template';\n      const template = document.currentScript.ownerDocument.querySelector(selector)\n      || document._currentScript.ownerDocument.querySelector(selector);\n\n      if (Shady && id) {\n        ShadyCSS.prepareTemplate(template, id);\n      }\n      return template;\n    }\n\n    trigger(eventName, options) {\n      this.dispatchEvent(new CustomEvent(eventName, {\n        detail: options || {},\n      }));\n    }\n\n    find(value, many) {\n      if (many) {\n        return this.root.querySelectorAll(value);\n      }\n      return this.root.getElementById(value);\n    }\n  };\n};\n","/**\n * This file prodides the @definition decorator which is used to setup the\n * definition of a custom component.\n *\n * Usage example\n * import { definition, APPEND } from 'definition';\n *\n * ...\n *\n * @definition('e-my-component', {\n *   style: 'someStyle',\n *   template: 'someTemplate',\n *   templatePosition: APPEND,\n *   props: {\n *     propName: { attribute: true, type: 'boolean' }\n *   }\n * })\n * class MyComponent extends TemplateComponent {}\n */\n\n/**\n * APPEND - Append the template to the existing markup of the component being extended (if any)\n */\nexport const APPEND = 1;\n\n/**\n * PREPEND = Prepend the template to the existing markup of the component being extended (if any)\n */\nexport const PREPEND = 2;\n\n/**\n * Set the template of the component. Setting the optional position of\n * where extended markup will be placed.\n *\n * @function setTemplates\n * @param { Object } target - Component.\n * @param { String } targetTemplate - template form the base component.\n * @param { String } optionTemplate - template form the extended component.\n * @param { String } pos - [PREPEND|APPEND] position fo the extended template.\n */\nfunction setTemplates(target, targetTemplate = null, optionTemplate = null, pos = APPEND) {\n  if (!targetTemplate && !optionTemplate) {\n    target.template = targetTemplate;\n  } else if (targetTemplate && optionTemplate) {\n    if (pos === PREPEND) {\n      target.template = `${optionTemplate}${targetTemplate}`;\n    } else if (pos === APPEND) {\n      target.template = `${targetTemplate}${optionTemplate}`;\n    }\n  } else if (!targetTemplate && optionTemplate) {\n    target.template = optionTemplate;\n  }\n}\n\n/**\n * Set the style of the compoenent\n *\n * @function setStyles\n * @param {*} target - Component.\n * @param {*} targetStyle - style from the base component.\n * @param {*} optionStyle - style from the extended component.\n */\nfunction setStyles(target, targetStyle = null, optionStyle = null) {\n  if (targetStyle && !optionStyle) {\n    target.style = targetStyle.toString();\n  } else if (targetStyle && optionStyle) {\n    target.style = `${targetStyle.toString()}${optionStyle.toString()}`;\n  } else if (!targetStyle && optionStyle) {\n    target.style = optionStyle.toString();\n  }\n}\n\n/**\n * Sets home of the component by dispatching 'GET_CONFIG' custom event\n * for getting the base path of the component.\n *\n * @function setHome\n * @param {Object} target - Component class\n * @param {Object} options - Component class properties\n * @fires document#GET_CONFIG\n */\nfunction setHome(target, options) {\n  const { home } = options;\n  target.home = home;\n\n  if (!home) {\n    return;\n  }\n\n  const configKeysPath = {\n    $components: 'component/componentsPath',\n  };\n\n  const callback = (data) => {\n    target.home = data.$components + home;\n  };\n\n  const _event = new CustomEvent('GET_CONFIG', {\n    detail: {\n      configKeysPath,\n      callback,\n    },\n  });\n\n  /**\n   * Get config event\n   * Container consumes this event if used inside it.\n   * @event document#GET_CONFIG\n   * @type {Object}\n   * @property {Object} detail.configKeysPath - path to default components directory\n   * @property {Function} detail.callback - callback function to trigger\n   */\n  document.dispatchEvent(_event);\n}\n\n/**\n * A decorator function which sets the decorated Class (target) as a custom component.\n * It allows the specification of the custom name (is),\n * the style and template (options).\n *\n * @function definition\n * @param { String } is - custom name of the component.\n * @param { Object } options - style, template, templatePosition and props of the component.\n */\nexport const definition = (is, options = {\n  style: null,\n  template: null,\n  templatePosition: null,\n  props: null,\n}) => (target) => {\n    target.is = is;\n    target.i18n = {};\n    setHome(target, options);\n    target._propDefs = { ...target._propDefs, ...options.props };\n    target._propDefs.locale = { attribute: false, type: 'string', default: '' };\n\n    setStyles(target, target.style, options.style);\n    setTemplates(target, target.template, options.template, options.templatePosition);\n  };\n","/* eslint arrow-body-style:0 */\nimport { prop, registerMixin, hasMixin } from '../utils/exports';\n\nexport const StoreMixin = (Base) => {\n  const mixinName = 'StoreMixin';\n  if (hasMixin(Base, mixinName)) {\n    console.warn(`Tried to add existing mixin ${mixinName}`);\n    return Base;\n  }\n\n  return class Store extends Base {\n    static get _mixins() {\n      return registerMixin(super._mixins, mixinName);\n    }\n\n    @prop({ attribute: false, type: 'object', default: {} })\n    state;\n\n    constructor(options) {\n      super(options);\n      this._stateChanged = this._stateChanged.bind(this);\n    }\n\n    /**\n     * @protected\n     * @function getState\n     * @description Get a state value from the Store\n     */\n    getState(key) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        return this.provider.store.getState(key);\n      }\n      return null;\n    }\n\n    /**\n     * @protected\n     * @function dispatch\n     * @description Dispatch a state update action, this will be captured by the App Store\n     */\n    dispatch(action, payload) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        this.provider.store.dispatch(action, payload);\n      }\n    }\n\n    /**\n     * @protected\n     * @function disconnect\n     * @description Disconnect the app from the store\n     * @param {Array} properties - The properties in the store previously registered\n     */\n    storeDisconnect(properties) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        return this.provider.store.disconnect(this, properties);\n      }\n      return null;\n    }\n\n    /**\n     * @protected\n     * @function connect\n     * @description Connect to the store and received update notifications for\n     * various state values\n     * @param {Array} properties - The properties in the store to request notification changes on\n     */\n    storeConnect(properties) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        return this.provider.store.connect(this, properties);\n      }\n      return null;\n    }\n\n    /**\n     * @protected\n     * @function addActions\n     * @description Set up an action listener\n     * @param {String} actionName - The action name to listen to, or an array of actions\n     * @param {Function} func - The action function (for single action only)\n     */\n    addActions(actionName, func) {\n     if (this.provider !== undefined && this.provider.store !== undefined) {\n       if (typeof actionName === 'string') {\n         this.provider.store.listen(actionName, func);\n       } else {\n         actionName.forEach((obj) => {\n           this.provider.store.listen(obj.name, obj.action);\n         });\n       }\n     }\n    }\n\n    /**\n     * @protected\n     * @function removeActions\n     * @description Remove an action listener(s)\n     * @param {String} actionName - The action name to listen to, or an array of actions\n     * @param {Function} func - The action function (for single action only)\n     */\n    removeActions(actionName, func) {\n      if (this.provider !== undefined && this.provider.store !== undefined) {\n        if (typeof actionName === 'string') {\n          this.provider.store.unlisten(actionName, func);\n        } else {\n          actionName.forEach((obj) => {\n            this.provider.store.unlisten(obj.name, obj.action);\n          });\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @function _stateChanged\n     * @description Function executed by the app store for state changes\n     * @param {Object} state - The state object with values for the execution\n     */\n    _stateChanged(state) {\n      const current = Object.assign({}, this.state);\n      Object.keys(current).forEach((key) => {\n        if (state[key] !== undefined) {\n          current[key] = state[key];\n        }\n      });\n      this.state = current;\n    }\n  };\n};\n","import StatelessComponentMixin from './Stateless';\nimport StatefulComponentMixin from './Component';\nimport Template from './renderers/Template';\n\n/* eslint no-undef:0 */\nexport class Stateless extends StatelessComponentMixin(HTMLElement) {}\nexport class Component extends StatefulComponentMixin(HTMLElement) {}\nexport class TemplateComponent extends Template(StatefulComponentMixin(HTMLElement)) {}\n\nexport {\n prop, registerMixin, hasMixin,\n} from './utils/exports';\nexport { definition, APPEND, PREPEND } from './utils/definition';\nexport { StoreMixin as Store } from './mixins/Store';\n"],"sourceRoot":""}