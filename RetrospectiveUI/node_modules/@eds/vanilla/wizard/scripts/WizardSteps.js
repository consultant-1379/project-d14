export class WizardSteps {
  constructor(element) {
    this.dom = {
      wizard: element,
      arrows: element.querySelectorAll('.arrow'),
      steps: element.querySelectorAll('.step'),
      points: null,
      id: element.getAttribute('id'),
    };
    this.state = null;
    this.scenario = 4;
    this.type = element.dataset.type;
    // this.contentTarget = element.dataset.content;
    this.events = {
      wizardState: new CustomEvent('wizardState', {
        detail: {
          message: 'state changed',
        },
        bubbles: true,
        cancelable: true,
      }),
    };
  }

  init() {
    this.setInitState();
    this.setInitContext();
    this.updateScenario();
    this.addEventListeners();
  }

  destroy() {
    this.addEventListeners();
  }

  addEventListeners() {
    const leftArrowDOM = this.dom.wizard.querySelector('.arrow.left');
    const rightArrowDOM = this.dom.wizard.querySelector('.arrow.right');

    rightArrowDOM.addEventListener('click', () => this.showNextSteps(), false);
    leftArrowDOM.addEventListener('click', () => this.showPrevSteps(), false);
    window.addEventListener('resize', () => this.updateScenario(), false);

    // add links to completed steps
    Array.from(this.dom.steps).forEach((step, i) => {
      step.addEventListener('click', () => {
        if (step.classList.contains('completed')) this.go2Step(i);
      }, false);
    });

    document.addEventListener('wizardStateChange', (e) => this.updateState(e), false);
    document.addEventListener('wizardShowNextSteps', () => this.showNextSteps(), false);
    document.addEventListener('wizardShowPrevSteps', () => this.showPrevSteps(), false);
  }

  removeEventListeners() {
    const leftArrowDOM = this.dom.wizard.querySelector('.arrow.left');
    const rightArrowDOM = this.dom.wizard.querySelector('.arrow.right');

    rightArrowDOM.removeEventListener('click', () => this.showNextSteps(), false);
    leftArrowDOM.removeEventListener('click', () => this.showPrevSteps(), false);
    window.removeEventListener('resize', () => this.updateScenario(), false);

    // add links to completed steps
    Array.from(this.dom.steps).forEach((step, i) => {
      step.removeEventListener('click', () => {
        if (step.classList.contains('completed')) this.go2Step(i);
      }, false);
    });

    document.removeEventListener('wizardStateChange', (e) => this.updateState(e), false);
    document.removeEventListener('wizardShowNextSteps', () => this.showNextSteps(), false);
    document.removeEventListener('wizardShowPrevSteps', () => this.showPrevSteps(), false);
  }

  updateState(event) {
    this.state = event.detail.state;
    this.updateDOM();
  }

  showArrow(arrowDirection) {
    switch (arrowDirection) {
      case 'left':
        this.dom.arrows[0].classList.add('visible');
        break;
      case 'right':
        this.dom.arrows[1].classList.add('visible');
        break;
    }
  }

  hideArrow(arrowDirection) {
    switch (arrowDirection) {
      case 'left':
        this.dom.arrows[0].classList.remove('visible');
        break;
      case 'right':
        this.dom.arrows[1].classList.remove('visible');
        break;
    }
  }

  setInitState() {
    const indexArray = Array.from(this.dom.steps).map((step, i) => i);
    this.state = {
      currentStep: 0,
      refIndex: 0,
      numSteps: this.dom.steps.length,
      allSteps: indexArray,
      presentation: indexArray.slice(0, this.scenario),
      prevSteps: [],
      nextSteps: indexArray.slice(this.scenario, this.dom.steps.length),
    };
    // add state to the event detail
    this.events.wizardState.detail.state = this.state;
    document.dispatchEvent(this.events.wizardState);
  }

  showNextSteps() {
    this.state.refIndex += 1;
    const potentialPresentation = this.state.allSteps.slice(this.state.refIndex, this.state.refIndex + this.scenario);
    if (potentialPresentation.length <= this.scenario) this.state.presentation = potentialPresentation;
    this.state.prevSteps = this.state.allSteps.slice(0, this.state.refIndex);
    this.state.nextSteps = this.state.allSteps.slice(this.state.refIndex + this.scenario, this.dom.steps.length);
    this.updateDOM();
  }

  showPrevSteps() {
    this.state.refIndex -= 1;
    this.state.presentation = this.state.allSteps.slice(this.state.refIndex, this.state.refIndex + this.scenario);
    this.state.prevSteps = this.state.allSteps.slice(0, this.state.refIndex);
    this.state.nextSteps = this.state.allSteps.slice(this.state.refIndex + this.scenario, this.dom.steps.length);
    this.updateDOM();
  }

  nextStep() {
    this.state.currentStep += 1;
    this.updateDOM();
  }

  prevStep() {
    this.state.currentStep -= 1;
    this.updateDOM();
  }

  updateDOM() {
    // keep values within limits
    this.keepRefIndexInBounds();

    // wizard step update
    this.updateDOMCurrentState();

    // wizard visibility
    this.updateDOMArrows();
    this.updateDOMStepsVisibility();

    // wizard navigation
    this.updateDOMContext();

    // dispatch change state event
    this.events.wizardState.detail.state = this.state;
    this.dom.wizard.dispatchEvent(this.events.wizardState);
  }

  updateDOMArrows() {
    if (this.state.nextSteps.length > 0) {
      this.showArrow('right');
    } else {
      this.hideArrow('right');
    }
    if (this.state.prevSteps.length > 0) {
      this.showArrow('left');
    } else {
      this.hideArrow('left');
    }
  }

  updateDOMCurrentState() {
    Array.from(this.dom.steps).forEach((step, i) => {
      // remove previous "current" states
      step.classList.remove('current');

      if (i < this.state.currentStep) step.classList.add('completed');
      // add correct current step
      if (i === this.state.currentStep) step.classList.add('current');
    });
  }

  updateDOMStepsVisibility() {
    Array.from(this.dom.steps).forEach((step, i) => {
      step.classList.add('hidden');
      step.classList.remove('visible');
      if (this.state.presentation.indexOf(i) > -1) {
        step.classList.remove('hidden');
        // to impose over the @media style
        step.classList.add('visible');
      }
    });
  }

  updateDOMContext() {
    Array.from(this.dom.points).forEach((point, i) => {

      // remove previous "current" points
      point.classList.remove('current');

      // add correct current point
      if (i === this.state.currentStep) point.classList.add('current');

      // update "out-of-context" points
      point.classList.add('out-of-presentation');
      if (this.state.presentation.indexOf(i) > -1) {
        point.classList.remove('out-of-presentation');
      }
    });
  }

  setInitContext() {
    const navigation = document.createElement('div');
    navigation.classList.add('navigation');
    Array.from(this.state.allSteps).forEach((step, i) => {
      const point = document.createElement('div');
      point.classList.add('point');

      // set current
      if (i === 0) point.classList.add('current');

      // set out-of-context if any
      if (this.state.nextSteps.indexOf(i) > -1) {
        point.classList.add('out-of-presentation');
      }

      navigation.appendChild(point);
    });
    this.dom.wizard.appendChild(navigation);
    this.dom.points = this.dom.wizard.querySelectorAll('.point');
  }

  // JS responsive steps
  updateScenario() {
    const width = window.innerWidth;
    switch (true) {

      /*
       * case (width >= 1400):
       *   this.scenario = 6;
       *   break;
       * case (width < 1400 && width >= 1200):
       *   this.scenario = 5;
       *   break;
       */
      case (width < 1200 && width >= 1000):
        this.scenario = 4;
        break;
      case (width < 1000 && width >= 700):
        this.scenario = 3;
        break;
      case (width < 700 && width >= 500):
        this.scenario = 2;
        break;
      case (width < 500):
        this.scenario = 1;
        break;
    }
    const potentialPresentation = this.state.allSteps.slice(this.state.refIndex, this.state.refIndex + this.scenario);
    if (potentialPresentation.length <= this.scenario) this.state.presentation = potentialPresentation;
    this.state.nextSteps = this.state.allSteps.slice(this.state.refIndex + this.scenario, this.dom.steps.length);
    this.updateDOM();
  }

  keepRefIndexInBounds() {
    if (this.state.refIndex < 0) {
      this.state.refIndex = 0;
    }
    const refIndexMax = this.state.numSteps - this.scenario;
    if (this.state.refIndex > refIndexMax) {
      this.state.refIndex = refIndexMax;
    }
  }

  go2Step(stepNumber) {
    const diff = this.state.currentStep - stepNumber;
    if (diff > 0) {
      for (let i = 0; i < diff; i += 1) {
        this.prevStep();
      }
    }
    if (diff < 0) {
      for (let j = 0; j < -diff; j += 1) {
        this.nextStep();
      }
    }
  }
}
