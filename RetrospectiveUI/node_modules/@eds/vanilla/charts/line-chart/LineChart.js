import * as d3 from 'd3';

import { Stage } from '../common/Stage';
import { Axis } from '../common/Axis';

export class LineChart {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {number} [props.height] - The height of the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {Object[]} [props.thresholds] - Thresholds that can be added to a chart
   * @param {number} [props.thresholds[].moreThan] - Sets the positive threshold
   * @param {number} [props.thresholds[].lessThan] - Sets the negative threshold
   * @param {string} [props.thresholds[].color] - Threshold color (green, yellow, orange, red)
   * @param {Object} [props.y] - Y axis properties
   * @param {boolean} [props.y.startFromZero] - If Y axis starts on zero
   * @param {boolean} [props.y.isLogarithmic] - If Y axis is logarithmic
   * @param {string} [props.y.unit] - The Y axis unit
   * @param {Object} [props.x] - X axis properties
   * @param {boolean} [props.x.isTime] - If X axis is time-based
   * @param {string} [props.x.unit] - The X axis unit
   */
  constructor(props) {
    this.dom = {
      id: props.element.getAttribute('id') || Date.now(),
    };
    this.element = props.element;
    this.height = props.height || 250;
    this.margin = {
      top: 25,
      bottom: 35,
      right: 25,
      left: 35,
      ...props.margin,
    };
    this.y = {
      startFromZero: true,
      isLogarithmic: false,
      unit: '',
      ...props.y,
    };
    this.x = {
      isTime: true,
      unit: '',
      ...props.x,
    };
    this.data = props.data;
    this.thresholds = props.thresholds;
  }

  /**
   * Initialize the chart
   */
  init() {
    this.stage = new Stage({
      element: this.element,
      margin: this.margin,
      height: this.height,
    });
    this.stage.init();

    this.stage.onResize(this.draw.bind(this));

    this.canvas = this.stage.getCanvas();
    if (this.x.isTime) {
      this.formatData();
    }
    this.draw();
  }

  /**
   * Draw the chart based on data
   * @param {Object[]} data - The data necessary to draw the chart
   */
  draw(data) {
    const jsonData = data || this.data;
    this.width = this.stage.getCanvasWidth();

    /**
     * X axis
     */
    // Time scale: default (time series)
    let x = d3.scaleTime()
      .domain(d3.extent(jsonData.common)).nice()
      .range([0, this.width]);

    // Linear scale: not time series
    if (!this.x.isTime) {
      x = d3.scaleLinear()
        .domain(d3.extent(jsonData.common)).nice()
        .range([0, this.width]);
    }
    // Create new X axis
    const xAxis = new Axis({
      position: 'bottom',
      canvas: this.canvas,
      x: x,
      width: this.width,
      height: this.height,
      fontSize: 14,
      axisPadding: 8,
      hasDomain: true,
    });
    // Init X axis & append to Canvas
    xAxis.init();

    /**
     * Y axis
     */
    // Linear scale: default (linear, start from zero)
    let y = d3.scaleLinear()
      .domain([0, d3.max(jsonData.series, d => d3.max(d.values))]).nice()
      .range([this.height, 0]);
    let tScale = d3.scaleLinear()
      .domain([0, d3.max(jsonData.series, d => d3.max(d.values))]).nice()
      .range([0, 100]);

    //  Logarithmic scale
    if (this.y.isLogarithmic) {
      y = d3.scaleLog()
        .domain([
          d3.min(jsonData.series, d => d3.min(d.values)),
          d3.max(jsonData.series, d => d3.max(d.values))
        ]).nice()
        .range([this.height, 0]);
    }
    //  Linear scale :not starting from zero
    if (!this.y.startFromZero) {
      y = d3.scaleLinear()
        .domain([
          d3.min(jsonData.series, d => d3.min(d.values)),
          d3.max(jsonData.series, d => d3.max(d.values))
        ]).nice()
        .range([this.height, 0]);
      tScale = d3.scaleLinear()
        .domain([
          d3.min(jsonData.series, d => d3.min(d.values)),
          d3.max(jsonData.series, d => d3.max(d.values))
        ]).nice()
        .range([0, 100]);
    }
    // Create new Y axis
    const yAxis = new Axis({
      position: 'left',
      canvas: this.canvas,
      y: y,
      width: this.width,
      height: this.height,
      fontSize: 14,
      axisPadding: 10,
      hasDomain: false,
      ticks: this.height / 60,
      thresholds: this.thresholds
    });
    // Init Y axis & append to Canvas
    yAxis.init();


    /**
     * Value line (path)
     */
    // Default path: date information
    const valueline = d3.line()
      .defined(d => !isNaN(d))
      .x((d, i) => x(jsonData.common[i]))
      .y(d => y(d));

    // Append path to Canvas
    const lines = this.canvas
      .classed('line-chart', true)
      .selectAll('.line').data(jsonData.series);

    // Enter
    lines
      .enter()
      .append('path')
      .classed('line', true)
      .attr('d', d => valueline(d.values))
      .attr('name', d => d.name);

    // Update
    this.canvas.selectAll('.line')
      .transition()
      .duration(400)
      .attr('d', d => valueline(d.values))
      .attr('name', d => d.name);

    // Exit
    lines.exit().remove();


    // Threshold
    if (this.thresholds) {
      let minValue = 0;
      if (!this.y.startFromZero) {
        minValue = d3.min(jsonData.series, d => d3.min(d.values));
      }
      const maxValue = d3.max(jsonData.series, d => d3.max(d.values));
      const input = this.thresholds;
      const output = [];

      output.push({
        offset: tScale(minValue),
        color: 'line'
      });
      input.forEach(element => {
        output.push({
          offset: tScale(element.moreThan || element.lessThan),
          color: 'line'
        });
        output.push({
          offset: tScale(element.moreThan || element.lessThan),
          color: 'line'
        });
      });
      output.push({
        offset: tScale(maxValue),
        color: 'line'
      });

      output.sort((a, b) => a.offset - b.offset);
      output.forEach(element => {
        element.offset = element.offset + '%';
      });

      // LessThan
      const lessThanArray = input.filter((element) => {
        if (element.lessThan) {
          return element;
        }
      });
      if (lessThanArray.length > 0) {
        lessThanArray.sort((a, b) => a.lessThan - b.lessThan);
        let j = 0;
        for (let i = 0; i < lessThanArray.length; i += 1) {
          output[j].color = lessThanArray[i].color;
          output[j + 1].color = lessThanArray[i].color;
          j += 2;
        }
      }

      // MoreThan
      const moreThanArray = input.filter((element) => {
        if (element.moreThan) {
          return element;
        }
      });
      if (moreThanArray.length > 0) {
        moreThanArray.sort((a, b) => b.moreThan - a.moreThan);
        let j = output.length - 1;
        for (let i = 0; i < moreThanArray.length; i += 1) {
          output[j].color = moreThanArray[i].color;
          output[j - 1].color = moreThanArray[i].color;
          j -= 2;
        }
      }

      this.canvas.append('linearGradient')
        .classed('linear-gradient', true)
        .attr('id', `gradient-${this.element.id}`)
        .attr('gradientUnits', 'userSpaceOnUse')
        .attr('x1', 0).attr('y1', this.height)
        .attr('x2', 0).attr('y2', 0)
        .selectAll('stop')
        .data(output)
        .enter().append('stop')
        .attr('offset', function (d) {
          return d.offset;
        })
        .attr('stop-color', function (d) {
          return d.color;
        });

      // Paint the lines with threshold colors
      const pathLines = this.element.querySelectorAll('path.line');
      Array.from(pathLines).forEach(line => {
        line.setAttribute('style', `stroke: url(#gradient-${this.element.id})`);
      });
    }
  }

  formatData() {
    const parseTime = d3.timeParse('%Y-%m-%d');
    this.data.common.forEach((date, i) => {
      if (!(date instanceof Date)) {
        this.data.common[i] = parseTime(date);
      }
    });
  }

  destroy() {
    this.stage.destroy();
  }

}
