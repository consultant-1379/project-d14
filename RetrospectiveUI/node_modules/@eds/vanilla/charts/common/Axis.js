import * as d3 from 'd3';

export class Axis {

  /**
   * Create common axis component for chart
   * @param {props} props - The properties for the axis component
   * @param {string} props.position - The predifined position for the axis: top, right, bottom or left
   * @param {Object} props.canvas - The DOM element to append the axis
   * @param {Object} [props.x] - The D3 x axis object
   * @param {Object} [props.y] - The D3 y axis object
   * @param {number} props.width - The width of the canvas
   * @param {number} props.height - The height of the canvas
   * @param {number} props.fontSize - The font size of the text elements in the axis
   * @param {number} props.axisPadding - The padding between the axis and the text elements
   * @param {number} [props.animationSpeed] - The speed of the animation if data changes
   * @param {Object[]} [props.thresholds] - Thresholds that can be added to a graph
   * @param {number} [props.thresholds[].moreThan] - Sets the positive threshold
   * @param {number} [props.thresholds[].lessThan] - Sets the negative threshold
   * @param {string} [props.thresholds[].color] - Threshold color (green, yellow, orange, red)
   * @param {boolean} [props.hasDomain] - Boolean determining the axis style to include domain or not
   * @param {number} [props.ticks] - The approximate number of ticks
   * @param {number} [props.tickFormat] - The number format for the ticks value (see D3 tickFormat)
   */
  constructor(props) {
    this.position = props.position;
    this.canvas = props.canvas;
    this.x = props.x;
    this.y = props.y;
    this.width = props.width;
    this.height = props.height;
    this.fontSize = props.fontSize;
    this.axisPadding = props.axisPadding;
    this.animationSpeed = props.animationSpeed || 400;
    this.thresholds = props.thresholds;
    this.hasDomain = props.hasDomain;
    this.ticks = props.ticks || this.width / 140;
    this.tickFormat = props.tickFormat;
  }

  /**
   * Initialize the axis
   */
  init() {
    this.draw();

    if (this.thresholds) {
      this.drawThreshold();
    }
  }

  /**
   * Draw an axis based on the properties defined
   */
  draw() {
    let axisConfig;

    const selectAxis = this.canvas.select(`.${this.position}.axis`);
    this.axis = selectAxis.empty() ? this.canvas.append('g') : selectAxis;

    switch (this.position) {
      case 'top': {
        axisConfig = d3
          .axisTop(this.x)
          .tickSize(-this.height - this.axisPadding)
          .ticks(this.ticks);
        break;
      }
      case 'right': {
        axisConfig = d3
          .axisRight(this.y)
          .tickSize(this.width)
          .ticks(this.ticks);
        break;
      }
      case 'bottom': {
        axisConfig = d3
          .axisBottom(this.x)
          .tickSize(this.hasDomain ? this.axisPadding : this.height + this.axisPadding)
          .tickPadding(this.axisPadding)
          .ticks(this.ticks);

        if (this.hasDomain) {
          this.axis.attr('transform', `translate(0,${this.height})`);
        }

        break;
      }
      case 'left': {
        axisConfig = d3
          .axisLeft(this.y)
          .tickSize(this.hasDomain ? this.axisPadding : -this.width)
          .tickPadding(this.axisPadding)
          .ticks(this.ticks);
        break;
      }
    }

    if (this.tickFormat) {
      axisConfig.tickFormat(d => this.tickFormat(d));
    }

    this.axis
      .classed(this.position, true)
      .classed('axis', true)
      .transition()
      .duration(this.animationSpeed)
      .call(axisConfig);

    if (!this.hasDomain) {
      this.axis.selectAll('.domain').remove();
    }
    this.axis.selectAll('.tick').selectAll('line')
      .classed('solid', this.hasDomain)
      .classed('zero', d => d === 0);

    this.axis.selectAll('.tick').selectAll('text')
      .attr('font-size', this.fontSize);
  }

  /**
   * Draw a threshold axis based on the properties defined
   * Threshold will be drawn on the opposite of the axis defined, e.g,
   * if the axis is on the left the threshold will be on the right
   */
  drawThreshold() {
    const equalsThreshold = d => {
      let threshold;
      this.thresholds.forEach(t => {
        if (d === t.moreThan || d === t.lessThan) {
          threshold = t.color;
        }
      });
      return threshold;
    };

    this.axis
      .selectAll('.tick')
      .classed('marked-for-removal', d => !!equalsThreshold(d));

    this.axis
      .selectAll('.tick.marked-for-removal')
      .remove();

    let axisConfig;

    const thresholdTicks = this.thresholds.map(threshold => threshold.moreThan || threshold.lessThan);

    switch (this.position) {
      case 'top': {
        axisConfig = d3
          .axisBottom(this.x)
          .tickPadding(this.axisPadding)
          .tickSize(this.height + this.axisPadding)
          .tickValues(thresholdTicks);
        break;
      }
      case 'right': {
        axisConfig = d3
          .axisLeft(this.y)
          .tickSize(-this.width)
          .tickValues(thresholdTicks);
        break;
      }
      case 'bottom': {
        axisConfig = d3
          .axisTop(this.x)
          .tickPadding(this.axisPadding)
          .tickSize(-this.height - this.axisPadding)
          .tickValues(thresholdTicks);
        break;
      }
      case 'left': {
        axisConfig = d3
          .axisRight(this.y)
          .tickSize(this.width)
          .tickValues(thresholdTicks);
        break;
      }
    }

    if (this.tickFormat) {
      axisConfig.tickFormat(d => this.tickFormat(d));
    }

    const selectThresholdAxis = this.canvas.select('.axis.threshold');
    this.thresholdAxis = selectThresholdAxis.empty() ? this.canvas.append('g') : selectThresholdAxis;

    this.thresholdAxis
      .classed('axis', true)
      .classed('threshold', true)
      .transition()
      .duration(this.animationSpeed)
      .call(axisConfig);

    this.thresholdAxis.selectAll('.domain').remove();
    this.thresholdAxis.selectAll('.tick').selectAll('line')
      .attr('class', d => equalsThreshold(d))
      .classed('threshold', true);

    this.thresholdAxis.selectAll('.tick').selectAll('text')
      .attr('font-size', this.fontSize)
      .attr('class', d => equalsThreshold(d));
  }
}
