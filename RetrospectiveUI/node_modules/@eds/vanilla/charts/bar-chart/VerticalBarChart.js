import * as d3 from 'd3';

import { Stage } from '../common/Stage';
import { Axis } from '../common/Axis';

export class VerticalBarChart {

  /**
   * Setup chart properties
   * @param {Object} props - The properties to initialize the stage
   * @param {Object[]} props.data - The data necessary to draw the chart
   * @param {HTMLElement} props.element - The DOM element to append the chart
   * @param {number} [props.height] - The height of the chart
   * @param {Object} [props.margin] - The top, right, bottom and left margins
   * @param {number} [props.margin.top] - The top margin
   * @param {number} [props.margin.right] - The right margin
   * @param {number} [props.margin.bottom] - The bottom margin
   * @param {number} [props.margin.left] - The left margin
   * @param {Object[]} [props.thresholds] - Thresholds that can be added to a chart
   * @param {number} [props.thresholds[].moreThan] - Sets the positive threshold
   * @param {number} [props.thresholds[].lessThan] - Sets the negative threshold
   * @param {string} [props.thresholds[].color] - Threshold color (green, yellow, orange, red)
   */
  constructor(props) {
    this.data = props.data;
    this.element = props.element;
    this.margin = {
      left: 40,
      right: 30,
      top: 30,
      bottom: 30,
      ...props.margin,
    };
    this.height = props.height || 250;
    this.thresholds = props.thresholds;
    this.axisPadding = 8;
    this.fontSize = 14;
    this.barWidth = 4;
    this.animationSpeed = 400;
  }

  /**
   * Initialize the chart
   */
  init() {
    this.stage = new Stage({
      element: this.element,
      margin: this.margin,
      height: this.height
    });
    this.stage.init();
    this.stage.onResize(this.draw.bind(this));

    this.canvas = this.stage.getCanvas();
    this.draw();
  }

  /**
   * Draw the chart based on data
   * @param {Object[]} data - The data necessary to draw the chart
   */
  draw(data) {
    this.data = data || this.data;
    this.width = this.stage.getCanvasWidth();

    const x = d3.scaleBand()
      .domain(d3.range(this.data.length))
      .rangeRound([0, this.width])
      .paddingInner(1)
      .paddingOuter(0.4);

    const y = d3.scaleLinear()
      .domain([
        d3.min(this.data, d => d.value) >= 0 ? 0 : d3.min(this.data, d => d.value),
        d3.max(this.data, d => d.value)
      ])
      .nice()
      .range([this.height, 0]);

    const axis = new Axis({
      position: 'left',
      canvas: this.canvas,
      y: y,
      width: this.width,
      height: this.height,
      fontSize: this.fontSize,
      axisPadding: this.axisPadding,
      thresholds: this.thresholds,
      ticks: this.height / 80
    });
    axis.init();

    const barDistance = x(1) - x(0);

    let hasTextSpace = true;
    let hasNegativeValues = false;
    this.data.forEach(d => {
      const valueLength = d.value.toString().length * this.fontSize / 1.5;
      const labelLength = d.label.length * this.fontSize / 1.5;

      if (hasTextSpace) {
        hasTextSpace = valueLength < barDistance && labelLength < barDistance;
      }

      if (!hasNegativeValues && d.value < 0) {
        hasNegativeValues = true;
      }
    });

    const bars = this.canvas
      .classed('bar-chart', true)
      .selectAll('.bar').data(this.data);

    const barPosition = selection => {
      selection.attr('transform', (d, i) => `translate(${x(i)}, ${y(0, d.value)})`);
    };

    const barLength = selection => {
      selection
        .attr('stroke-width', this.barWidth)
        .attr('class', d => {
          let color;
          if (this.thresholds) {
            this.thresholds
              .sort((a,b) => a.moreThan - b.moreThan || b.lessThan - a.lessThan)
              .forEach(t => {
                if (t.moreThan && d.value >= t.moreThan || t.lessThan && d.value <= t.lessThan) {
                  color = t.color;
                }
              });
            return color;
          }
        })
        .classed('line', true)
        .transition()
        .duration(this.animationSpeed)
        .attr('y2', d => y(d.value) - y(0));
    };

    const barValue = selection => {
      selection
        .attr('text-anchor', 'middle')
        .text(d => d.value)
        .classed('label', true)
        .classed('value', true)
        .classed('hidden', !hasTextSpace)
        .transition()
        .duration(this.animationSpeed)
        .attr('y', d => y(d.value) - y(0) + (d.value >= 0 ? -4 : this.fontSize));
    };

    const barLabel = selection => {
      selection
        .attr('y', d => hasNegativeValues ? this.height - y(0, d.value) + this.margin.bottom : this.fontSize + 2)
        .attr('text-anchor', 'middle')
        .text(d => d.label)
        .classed('label', true)
        .classed('text', true)
        .classed('hidden', !hasTextSpace)
        .transition()
        .duration(this.animationSpeed);
    };

    const barsEnter = bars.enter()
      .append('g')
      .classed('bar', true)
      .call(barPosition);

    const barHover = selection => {
      const all = barsEnter.merge(bars).selectAll('.line');
      const allLabelsValue = barsEnter.merge(bars).selectAll('.label.value');
      const allLabelsText = barsEnter.merge(bars).selectAll('.label.text');
      selection
        .classed('line-hover', true)
        .attr('y1', -this.height)
        .attr('y2', this.height)
        .attr('stroke', 'blue')
        .attr('opacity', '0')
        .attr('stroke-width', barDistance)
        .on('mouseover', function () {
          const hovered = d3.select(this.parentNode).select('.line');
          const labelValue = d3.select(this.parentNode).select('.label.value');
          const labelText = d3.select(this.parentNode).select('.label.text');

          labelValue.classed('hidden', false);
          labelText.classed('hidden', false);
          all.classed('inactive', true);
          allLabelsValue.classed('inactive', true);
          allLabelsText.classed('active', hasTextSpace);

          hovered.classed('active', true);
          hovered.classed('inactive', false);
          labelValue.classed('active', true);
          labelValue.classed('inactive', false);
          labelText.classed('active', true);
          labelText.classed('inactive', false);
        })
        .on('mouseout', function () {
          const hovered = d3.select(this.parentNode).select('.line');
          const labelValue = d3.select(this.parentNode).select('.label.value');
          const labelText = d3.select(this.parentNode).select('.label.text');

          labelValue.classed('hidden', !hasTextSpace);
          labelText.classed('hidden', !hasTextSpace);
          all.classed('inactive', false);
          allLabelsValue.classed('inactive', false);
          allLabelsText.classed('inactive', !hasTextSpace);

          hovered.classed('active', false);
          labelValue.classed('active', false);
          labelText.classed('active', false);
        });
    };

    // Enter
    barsEnter
      .append('line')
      .classed('line', true);

    barsEnter
      .select('.line')
      .call(barLength);

    barsEnter
      .append('text')
      .call(barValue);

    barsEnter
      .append('text')
      .call(barLabel);

    barsEnter
      .append('line')
      .call(barHover);

    // Update
    bars
      .call(barPosition);

    bars
      .select('.line')
      .call(barLength);

    bars
      .select('.label.value')
      .call(barValue);

    bars
      .select('.label.text')
      .call(barLabel);

    bars
      .select('.line-hover')
      .call(barHover);

    // Remove
    bars.exit().remove();
  }

  destroy() {
    this.stage.destroy();
  }
}
